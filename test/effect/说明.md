上一篇我们已经实现了一个基本具备响应式的 effect 副作用函数，我们只要通过调用 effect 函数，传入一个 fn 函数，effect 副作用就会自动对 fn 函数内部的数据进行依赖收集，修改数据的时候会触发对应的回调函数。

```javascript
const obj = {
  foo: 1
}

const proxyObj = new Proxy(obj, {
  get(target, key) {
    track(target, key)
    return target[key]
  }
  set(target, key, value) {
    target[key] = value
    trigger(target, key)
    return true;
  }
})

effect(() => {
  console.log(proxyObj.foo)
})
```

哈哈哈不要以为这样写就实现了响应式呢，以上的写法还是存在弊端的，耐心看下去，我一一来解释：
1、当 obj 对象里面有访问器属性的时候,结合上面的例子，我现在新增了一个 bar 属性，它是一个 getter 访问器属性，假设现在在 effect 函数里面访问了 proxyObj.foo,fn 函数会执行一次，然后我们修改了 proxyObj.foo 属性的值，effect 副作用函数并没有重新执行，为什么呢？让我们把关注点移到 effect 的 fn 函数内部，我们读取 proxyObj.bar,然后 target[key]等价于 this.obj,此时的 this 指的是 obj.foo, obj 只是一个普通对象，试问读取一个普通对象的属性怎么会触发依赖收集呢？

```javascript
const obj = {
  foo: 1,
  get bar() {
    return this.foo;
  },
};

effect(() => {
  console.log(proxyObj.bar);
});

proxyObj.foo = 2;
```

那如何解决这个问题呢，就需要用到 Reflect 对象了，具体如果不知道 Reflect 对象，请自行查阅了，此处不做过多解释，Reflect.get()方法会读取对象的属性，它的第一个参数是目标对象，第二个参数是属性名，第三个参数可以设置 this 指向，我们把 this 指向 proxyObj,那最终访问的就是 proxyObj 的 foo 属性，这样不就可以触发依赖收集了。现在执行以下代码，就可以正常触发了。

```javascript
const proxyObj = new Proxy(obj, {
  get(target, key, receiver) {
    track(target, key)
    return Reflect.get(target, key, receiver)
  }
  set(target, key, value, receiver) {
    Reflect.set(target, key, value, receiver)
    trigger(target, key)
    return true;
  }
})

const obj = {
  foo: 1,
  get bar() {
    return this.foo
  }
}

effect(() => {
  console.log(proxyObj.bar)
})

proxyObj.foo = 2
```

第二个问题，总所周知，读取是个很宽泛的东西，obj.xxx 只是一个正常且常见的读取方式，xxx in obj 是一个判断属性是否存在的读取方式，for(xxx in obj)是一个遍历的读取方式，因此设置代理的方式还是需要继续完善。
1、 in 操作符，它的底层会使用 hasProperty 方法去做判断，对应 proxy 的拦截函数就是 has，因此需要将 in 操作符的判断逻辑也进行代理。以下是伪代码：

```javascript
new Proxy(obj, {
  has(target, key) {
    track(target, key);
    return Reflect.has(target, key);
  },
});
```

2、for in 循环读取操作，，它的底层会用到 Reflect.ownKeys 方法，对应在 proxy 的拦截函数就是 ownKeys，因此也需要进行代理。以下是伪代码：

```javascript
const TACK_KEY = Symbol();

const proxyObj = new Proxy(obj, {
  ownKeys(target) {
    track(target, TACK_KEY);
    return Reflect.ownKeys(target);
  },
  get(target, key, receiver) {
    track(target, key)
    return Reflect.get(target, key, receiver)
  }
  set(target, key, value, receiver) {
    Reflect.set(target, key, value, receiver)
    trigger(target, key)
    return true;
  }
})

effect(() => {
  for(let x in proxyObj) {
    xxxx
  }
})
```

以上逻辑，当我们在 effect 副作用函数里使用 for in 循环读取的时候，已经可以正常进行依赖收集了。好，我现在给 obj 加入一个属性 name，按道理来说，for in 的循环次数会发生变化，所以当新增了一个属性的时候，for in 循环逻辑也应该要触发才合理，但是现在明显做不到，新增了一个属性 name，只会触发与 name 相关的依赖，而不会触发 for in 循环的依赖。解决方法很简单，就是在依赖触发 trigger 函数里面，除了取出当前 key 的依赖集合外，也取出 TRANCK_KEY 的依赖集合一起执行，就可以解决这个问题。

```javascript
function trigger(target, key) {
  let depsMap = bucket.get(target);
  if (!depsMap) return;
  let deps = depsMap.get(key);
  let iterateEffects = depsMap.get(TRACK_KEY);
  // 为什么需要新开一个Set呢，因为在遍历deps的时候，执行effectFn函数时会执行【清除依赖，执行fn依赖收集】，始终对同一个set操作，会死循环
  const newSet = new Set();
  iterateEffects &&
    iterateEffects.forEach((fn) => {
      if (fn !== activeEffect) {
        newSet.add(fn);
      }
    });
  deps &&
    deps.forEach((dep) => {
      if (fn !== activeEffect) {
        newSet.add(dep);
      }
    });
  newSet &&
    newSet.forEach((fn) => {
      // 为什么需要加以下判断呢？试想以下执行effectFn时，同时存在属性的读写，会导致死循环
      if (fn !== activeEffect) {
        if (fn.options.scheduler) {
          fn.options.scheduler(fn);
        } else {
          fn();
        }
      }
    });
}
```

但是 trigger 函数里存在一定的性能损耗，每次 trigger，都无脑执行 TRACK_KEY 的依赖集合显然是不合理的，如果是 set 值的话，对 for in 循环是不影响的，都是循环这么多遍，只有 add key 的时候才会影响到 for in 函数,所以需要给 trigger 函数补充一个入参，如果是 add 类型操作就执行 TRACK_KEY 的依赖集合，否则就不执行

```javascript
const proxyObj = new Proxy(obj, {
  set(target, key, value, receiver) {
    const type = Object.prototype.hasOwnProperty.call(target, key)
      ? "set"
      : "add";
    Reflect.set(target, key, value, receiver);
    trigger(target, key, type);
    return true;
  },
});

function trigger(target, key, type) {
  let depsMap = bucket.get(target);
  if (!depsMap) return;
  let deps = depsMap.get(key);
  // 更新逻辑------------
  const newSet = new Set();
  if (type === "add") {
    let iterateEffects = depsMap.get(TRACK_KEY);
    iterateEffects &&
      iterateEffects.forEach((fn) => {
        if (fn !== activeEffect) {
          newSet.add(fn);
        }
      });
  }
  // 更新逻辑------------

  deps &&
    deps.forEach((dep) => {
      if (fn !== activeEffect) {
        newSet.add(dep);
      }
    });
  newSet &&
    newSet.forEach((fn) => {
      // 为什么需要加以下判断呢？试想以下执行effectFn时，同时存在属性的读写，会导致死循环
      if (fn !== activeEffect) {
        if (fn.options.scheduler) {
          fn.options.scheduler(fn);
        } else {
          fn();
        }
      }
    });
}
```
