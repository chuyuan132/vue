上一篇我们已经实现了一个基本具备响应式的 effect 副作用函数，我们只要通过调用 effect 函数，传入一个 fn 函数，effect 副作用就会自动对 fn 函数内部的数据进行依赖收集，修改数据的时候会触发对应的回调函数。

```javascript
const obj = {
  foo: 1
}

const proxyObj = new Proxy(obj, {
  get(target, key) {
    track(target, key)
    return target[key]
  }
  set(target, key, value) {
    target[key] = value
    trigger(target, key)
    return true;
  }
})

effect(() => {
  console.log(proxyObj.foo)
})
```

哈哈哈不要以为这样写就实现了响应式呢，以上的写法还是存在弊端的，耐心看下去，我一一来解释：
1、当 obj 对象里面有访问器属性的时候,结合上面的例子，我现在新增了一个 bar 属性，它是一个 getter 访问器属性，假设现在在 effect 函数里面访问了 proxyObj.foo,fn 函数会执行一次，然后我们修改了 proxyObj.foo 属性的值，effect 副作用函数并没有重新执行，为什么呢？让我们把关注点移到 effect 的 fn 函数内部，我们读取 proxyObj.bar,然后 target[key]等价于 this.obj,此时的 this 指的是 obj.foo, obj 只是一个普通对象，试问读取一个普通对象的属性怎么会触发依赖收集呢？

```javascript
const obj = {
  foo: 1,
  get bar() {
    return this.foo;
  },
};

effect(() => {
  console.log(proxyObj.bar);
});

proxyObj.foo = 2;
```

那如何解决这个问题呢，就需要用到 Reflect 对象了，具体如果不知道 Reflect 对象，请自行查阅了，此处不做过多解释，Reflect.get()方法会读取对象的属性，它的第一个参数是目标对象，第二个参数是属性名，第三个参数可以设置 this 指向，我们把 this 指向 proxyObj,那最终访问的就是 proxyObj 的 foo 属性，这样不就可以触发依赖收集了。现在执行以下代码，就可以正常触发了。

```javascript
const proxyObj = new Proxy(obj, {
  get(target, key, receiver) {
    track(target, key)
    return Reflect.get(target, key, receiver)
  }
  set(target, key, value, receiver) {
    Reflect.set(target, key, value, receiver)
    trigger(target, key)
    return true;
  }
})

const obj = {
  foo: 1,
  get bar() {
    return this.foo
  }
}

effect(() => {
  console.log(proxyObj.bar)
})

proxyObj.foo = 2
```

第二个问题，总所周知，读取是个很宽泛的东西，obj.xxx 只是一个正常且常见的读取方式，xxx in obj 是一个判断属性是否存在的读取方式，for(xxx in obj)是一个遍历的读取方式，因此设置代理的方式还是需要继续完善。
1、 in 操作符，它的底层会使用 hasProperty 方法去做判断，对应 proxy 的拦截函数就是 has，因此需要将 in 操作符的判断逻辑也进行代理。以下是伪代码：

```javascript
new Proxy(obj, {
  has(target, key) {
    track(target, key);
    return Reflect.has(target, key);
  },
});
```

2、for in 循环读取操作，，它的底层会用到 Reflect.ownKeys 方法，对应在 proxy 的拦截函数就是 ownKeys，因此也需要进行代理。以下是伪代码：

```javascript
const TACK_KEY = Symbol();

const proxyObj = new Proxy(obj, {
  ownKeys(target) {
    track(target, TACK_KEY);
    return Reflect.ownKeys(target);
  },
  get(target, key, receiver) {
    track(target, key)
    return Reflect.get(target, key, receiver)
  }
  set(target, key, value, receiver) {
    Reflect.set(target, key, value, receiver)
    trigger(target, key)
    return true;
  }
})

effect(() => {
  for(let x in proxyObj) {
    xxxx
  }
})
```

以上逻辑，当我们在 effect 副作用函数里使用 for in 循环读取的时候，已经可以正常进行依赖收集了。好，我现在给 obj 加入一个属性 name，按道理来说，for in 的循环次数会发生变化，所以当新增了一个属性的时候，for in 循环逻辑也应该要触发才合理，但是现在明显做不到，新增了一个属性 name，只会触发与 name 相关的依赖，而不会触发 for in 循环的依赖。解决方法很简单，就是在依赖触发 trigger 函数里面，除了取出当前 key 的依赖集合外，也取出 TRANCK_KEY 的依赖集合一起执行，就可以解决这个问题。

```javascript
function trigger(target, key) {
  let depsMap = bucket.get(target);
  if (!depsMap) return;
  let deps = depsMap.get(key);
  let iterateEffects = depsMap.get(TRACK_KEY);
  // 为什么需要新开一个Set呢，因为在遍历deps的时候，执行effectFn函数时会执行【清除依赖，执行fn依赖收集】，始终对同一个set操作，会死循环
  const newSet = new Set();
  iterateEffects &&
    iterateEffects.forEach((fn) => {
      if (fn !== activeEffect) {
        newSet.add(fn);
      }
    });
  deps &&
    deps.forEach((dep) => {
      if (fn !== activeEffect) {
        newSet.add(dep);
      }
    });
  newSet &&
    newSet.forEach((fn) => {
      // 为什么需要加以下判断呢？试想以下执行effectFn时，同时存在属性的读写，会导致死循环
      if (fn !== activeEffect) {
        if (fn.options.scheduler) {
          fn.options.scheduler(fn);
        } else {
          fn();
        }
      }
    });
}
```

但是 trigger 函数里存在一定的性能损耗，每次 trigger，都无脑执行 TRACK_KEY 的依赖集合显然是不合理的，如果是 set 值的话，对 for in 循环是不影响的，都是循环这么多遍，只有 add 和 delete 的时候才会影响到 for in 函数,所以需要给 trigger 函数补充一个入参，如果是 add/delete 类型操作就执行 TRACK_KEY 的依赖集合，否则就不执行

```javascript
const proxyObj = new Proxy(obj, {
  set(target, key, value, receiver) {
    const type = Object.prototype.hasOwnProperty.call(target, key)
      ? "set"
      : "add";
    Reflect.set(target, key, value, receiver);
    trigger(target, key, type);
    return true;
  },
});

function trigger(target, key, type) {
  let depsMap = bucket.get(target);
  if (!depsMap) return;
  let deps = depsMap.get(key);
  // 更新逻辑------------
  const newSet = new Set();
  if ([TrgetType.ADD, TrgetType.DELETE].includes(type)) {
    let iterateEffects = depsMap.get(TRACK_KEY);
    iterateEffects &&
      iterateEffects.forEach((fn) => {
        if (fn !== activeEffect) {
          newSet.add(fn);
        }
      });
  }
  // 更新逻辑------------

  deps &&
    deps.forEach((dep) => {
      if (fn !== activeEffect) {
        newSet.add(dep);
      }
    });
  newSet &&
    newSet.forEach((fn) => {
      // 为什么需要加以下判断呢？试想以下执行effectFn时，同时存在属性的读写，会导致死循环
      if (fn !== activeEffect) {
        if (fn.options.scheduler) {
          fn.options.scheduler(fn);
        } else {
          fn();
        }
      }
    });
}
```

最后一个是属性的删除，删除操作也会影响 for in 循环的次数，所以也要处理

```javascript
new Proxy(obj, {
  deleteProperty(target, key) {
    const hadKey = Object.prototype.hasOwnProperty.call(target, key);
    const res = Reflect.deleteProperty(target, key);
    if (res && hadKey) {
      trigger(target, key, TriggerType.DELETE);
    }
    return res;
  },
});
```

最后的代码：

```javascript
/**
 * 存储桶
 * @type {WeakMap<WeakKey, Map<key, Set>>}
 */
const bucket = new WeakMap();
/**
 * 当前激活的副作用函数
 * @type {null}
 */
let activeEffect = null;
/**
 * 副作用函数执行栈
 * @type {*[]}
 */
const effectStack = [];

const defaultOptions = {
  scheduler: null,
  lazy: false,
};

const TriggerType = {
  ADD: "add",
  SET: "set",
  DELETE: "delete",
};

/**
 * 将fn包装成一个副作用函数，在目标函数执行上下文加入自定义的逻辑
 * @param fn
 * @param options
 * @returns {function(): *}
 */
const TRACK_KEY = Symbol();

/**
 * 将fn包装成一个副作用函数，在目标函数执行上下文加入自定义的逻辑
 * @param fn
 * @param options
 * @returns {function(): *}
 */
function effect(fn, options = defaultOptions) {
  // 对fn进行一层包装，融入自定义的上下文逻辑
  function effectFn() {
    clean(effectFn); // 将当前副作用函数从所有依赖集合中移除
    activeEffect = effectFn; // 将当前副作用函数赋值给全局变量，用于依赖收集
    effectStack.push(effectFn); // 处理嵌套Effect问题
    const res = fn(); // 处理获取fn函数返回值
    effectStack.pop();
    activeEffect = effectStack[effectStack.length - 1];
    return res;
  }
  // 开始执行具体逻辑
  effectFn.deps = [];
  effectFn.options = options;
  if (options.lazy) {
    return effectFn;
  }
  effectFn();
}

/**
 * 副作用清理函数
 * @param effectFn
 */
/**
 * 副作用清理函数
 * @param effectFn
 */
function clean(effectFn) {
  for (let i = 0; i < effectFn.deps.length; i++) {
    const deps = effectFn.deps[i];
    deps.delete(effectFn);
  }
  // [].delete不会动态改变数组长度，需要手动处理
  effectFn.deps.length = 0;
}

/**
 * 依赖收集，核心是通过activeEffect全局变量来实现的
 * @param target
 * @param key
 */
/**
 * 依赖收集，核心是通过activeEffect全局变量来实现的
 * @param target
 * @param key
 */
function track(target, key) {
  if (!activeEffect) return;
  let depsMap = bucket.get(target);
  if (!depsMap) {
    bucket.set(target, (depsMap = new Map()));
  }
  let deps = depsMap.get(key);
  if (!deps) {
    depsMap.set(key, (deps = new Set()));
  }
  deps.add(activeEffect);
  activeEffect.deps.push(deps);
}

/**
 * 依赖触发
 * @param target
 * @param key
 */
function trigger(target, key) {
  let depsMap = bucket.get(target);
  if (!depsMap) return;
  let deps = depsMap.get(key);

  // 为什么需要新开一个Set呢，因为在遍历deps的时候，执行effectFn函数时会执行【清除依赖，执行fn依赖收集】，始终对同一个set操作，会死循环
  const newSet = new Set();

  if ([TriggerType.ADD, TriggerType.DELETE].includes(type)) {
    let iterateEffects = depsMap.get(TRACK_KEY);
    iterateEffects &&
      iterateEffects.forEach((fn) => {
        if (fn !== activeEffect) {
          newSet.add(fn);
        }
      });
  }

  deps &&
    deps.forEach((dep) => {
      if (fn !== activeEffect) {
        newSet.add(dep);
      }
    });
  newSet &&
    newSet.forEach((fn) => {
      // 为什么需要加以下判断呢？试想以下执行effectFn时，同时存在属性的读写，会导致死循环
      if (fn !== activeEffect) {
        if (fn.options.scheduler) {
          fn.options.scheduler(fn);
        } else {
          fn();
        }
      }
    });
}

/**
 * 创建proxy对象代理
 * @param obj
 * @returns {*|object|boolean}
 */
/**
 * 创建proxy对象代理
 * @param obj
 * @returns {*|object|boolean}
 */
function createProxy(obj) {
  return new Proxy(obj, {
    get(target, key, receiver) {
      track(target, key);
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      const type = Object.prototype.hasOwnProperty.call(target, key)
        ? TriggerType.SET
        : TriggerType.ADD;
      Reflect.set(target, key, value, receiver);
      trigger(target, key, type);
      return true;
    },
    has(target, key) {
      track(target, key);
      return Reflect.has(target, key);
    },
    ownKeys(target) {
      track(target, TRACK_KEY);
      return Reflect.ownKeys(target);
    },
    deleteProperty(target, key) {
      const hadKey = Object.prototype.hasOwnProperty.call(target, key);
      const res = Reflect.deleteProperty(target, key);
      if (res && hadKey) {
        trigger(target, key, TriggerType.DELETE);
      }
      return res;
    },
  });
}

export { effect, createProxy, track, trigger };
```
